[{"title":"OS","indent":0},{"indent":0,"title":"OS"},{"indent":1,"title":"Interfaces"},{"indent":2,"title":"Bash"},{"indent":3,"title":"https://en.wikipedia.org/wiki/Bash_(Unix_shell)"},{"indent":3,"title":"resources"},{"indent":4,"title":"https://github.com/jlevy/the-art-of-command-line?utm_campaign=explore-email&utm_medium=email&utm_source=newsletter&utm_term=weekly"},{"indent":5,"title":"Everyday use"},{"indent":5,"content":"<h2>Everyday use</h2><ul><li><p>In Bash, use&#xA0;<strong>Tab</strong>&#xA0;to complete arguments or list all available commands and&#xA0;<strong>ctrl-r</strong>&#xA0;to search through command history (after pressing, type to search, press&#xA0;<strong>ctrl-r</strong>&#xA0;repeatedly to cycle through more matches, press&#xA0;<strong>Enter</strong>&#xA0;to execute the found command, or hit the right arrow to put the result in the current line to allow editing).</p></li><li><p>In Bash, use&#xA0;<strong>ctrl-w</strong>&#xA0;to delete the last word, and&#xA0;<strong>ctrl-u</strong>&#xA0;to delete all the way back to the start of the line. Use&#xA0;<strong>alt-b</strong>&#xA0;and&#xA0;<strong>alt-f</strong>&#xA0;to move by word,&#xA0;<strong>ctrl-a</strong>&#xA0;to move cursor to beginning of line,&#xA0;<strong>ctrl-e</strong>&#xA0;to move cursor to end of line,&#xA0;<strong>ctrl-k</strong>&#xA0;to kill to the end of the line,&#xA0;<strong>ctrl-l</strong>&#xA0;to clear the screen. See&#xA0;<code>man readline</code>&#xA0;for all the default keybindings in Bash. There are a lot. For example&#xA0;<strong>alt-.</strong>&#xA0;cycles through previous arguments, and&#xA0;<strong>alt-</strong>* expands a glob.</p></li><li><p>Alternatively, if you love vi-style key-bindings, use&#xA0;<code>set -o vi</code>&#xA0;(and&#xA0;<code>set -o emacs</code>&#xA0;to put it back).</p></li><li><p>For editing long commands, after setting your editor (for example&#xA0;<code>export EDITOR=vim</code>),&#xA0;<strong>ctrl-x</strong>&#xA0;<strong>ctrl-e</strong>&#xA0;will open the current command in an editor for multi-line editing. Or in vi style,&#xA0;<strong>escape-v</strong>.</p></li><li><p>To see recent commands,&#xA0;<code>history</code>. There are also many abbreviations such as&#xA0;<code>!$</code>&#xA0;(last argument) and&#xA0;<code>!!</code>&#xA0;last command, though these are often easily replaced with&#xA0;<strong>ctrl-r</strong>&#xA0;and&#xA0;<strong>alt-.</strong>.</p></li><li><p>To go back to the previous working directory:&#xA0;<code>cd -</code></p></li><li><p>If you are halfway through typing a command but change your mind, hit&#xA0;<strong>alt-#</strong>&#xA0;to add a&#xA0;<code>#</code>&#xA0;at the beginning and enter it as a comment (or use&#xA0;<strong>ctrl-a</strong>,&#xA0;<strong>#</strong>,&#xA0;<strong>enter</strong>). You can then return to it later via command history.</p></li><li><p>Use&#xA0;<code>xargs</code>&#xA0;(or&#xA0;<code>parallel</code>). It&apos;s very powerful. Note you can control how many items execute per line (<code>-L</code>) as well as parallelism (<code>-P</code>). If you&apos;re not sure if it&apos;ll do the right thing, use&#xA0;<code>xargs echo</code>first. Also,&#xA0;<code>-I{}</code>&#xA0;is handy. Examples:</p></li></ul><div class=\"highlight highlight-bash\"><pre>      find <span class=\"pl-c1\">.</span> -name <span class=\"pl-s\"><span class=\"pl-pds\">&apos;</span>*.py<span class=\"pl-pds\">&apos;</span></span> <span class=\"pl-k\">|</span> xargs grep some_function\n      cat hosts <span class=\"pl-k\">|</span> xargs -I{} ssh root@{} hostname</pre></div><ul><li><p><code>pstree -p</code>&#xA0;is a helpful display of the process tree.</p></li><li><p>Use&#xA0;<code>pgrep</code>&#xA0;and&#xA0;<code>pkill</code>&#xA0;to find or signal processes by name (<code>-f</code>&#xA0;is helpful).</p></li><li><p>Know the various signals you can send processes. For example, to suspend a process, use&#xA0;<code>kill -STOP [pid]</code>. For the full list, see&#xA0;<code>man 7 signal</code></p></li><li><p>Use&#xA0;<code>nohup</code>&#xA0;or&#xA0;<code>disown</code>&#xA0;if you want a background process to keep running forever.</p></li><li><p>Check what processes are listening via&#xA0;<code>netstat -lntp</code>&#xA0;or&#xA0;<code>ss -plat</code>&#xA0;(for TCP; add&#xA0;<code>-u</code>&#xA0;for UDP).</p></li><li><p>See also&#xA0;<code>lsof</code>&#xA0;for open sockets and files.</p></li><li><p>See&#xA0;<code>uptime</code>&#xA0;or&#xA0;<code>w</code>&#xA0;to know the how long the system has been running.</p></li><li><p>Use&#xA0;<code>alias</code>&#xA0;to create shortcuts for commonly used commands. For example,&#xA0;<code>alias ll=&apos;ls -latr&apos;</code>&#xA0;creates a new alias&#xA0;<code>ll</code>.</p></li><li><p>In Bash scripts, use&#xA0;<code>set -x</code>&#xA0;(or the variant&#xA0;<code>set -v</code>, which logs raw input, including unexpanded variables and comments) for debugging output. Use strict modes unless you have a good reason not to: Use&#xA0;<code>set -e</code>&#xA0;to abort on errors (nonzero exit code). Use&#xA0;<code>set -u</code>&#xA0;to detect unset variable usages. Consider&#xA0;<code>set -o pipefail</code>&#xA0;too, to on errors within pipes, too (though read up on it more if you do, as this topic is a bit subtle). For more involved scripts, also use&#xA0;<code>trap</code>&#xA0;on EXIT or ERR. A useful habit is to start a script like this, which will make it detect and abort on common errors and print a message:</p></li></ul><div class=\"highlight highlight-bash\"><pre>      <span class=\"pl-c1\">set</span> -euo pipefail\n      <span class=\"pl-c1\">trap</span> <span class=\"pl-s\"><span class=\"pl-pds\">&quot;</span>echo &apos;error: Script failed: see failed command above&apos;<span class=\"pl-pds\">&quot;</span></span> ERR</pre></div><ul><li>In Bash scripts, subshells (written with parentheses) are convenient ways to group commands. A common example is to temporarily move to a different working directory, e.g.</li></ul><div class=\"highlight highlight-bash\"><pre>      <span class=\"pl-c\"># do something in current dir</span>\n      (<span class=\"pl-c1\">cd</span> /some/other/dir <span class=\"pl-k\">&amp;&amp;</span> other-command)\n      <span class=\"pl-c\"># continue in original dir</span></pre></div><ul><li><p>In Bash, note there are lots of kinds of variable expansion. Checking a variable exists:&#xA0;<code>${name:?error message}</code>. For example, if a Bash script requires a single argument, just write<code>input_file=${1:?usage: $0 input_file}</code>. Arithmetic expansion:&#xA0;<code>i=$(( (i + 1) % 5 ))</code>. Sequences:&#xA0;<code>{1..10}</code>. Trimming of strings:&#xA0;<code>${var%suffix}</code>&#xA0;and&#xA0;<code>${var#prefix}</code>. For example if<code>var=foo.pdf</code>, then&#xA0;<code>echo ${var%.pdf}.txt</code>&#xA0;prints&#xA0;<code>foo.txt</code>.</p></li><li><p>Brace expansion using&#xA0;<code>{</code>...<code>}</code>&#xA0;can reduce having to re-type similar text and automate combinations of items. This is helpful in examples like&#xA0;<code>mv foo.{txt,pdf} some-dir</code>&#xA0;(which moves both files),&#xA0;<code>cp somefile{,.bak}</code>&#xA0;(which expands to&#xA0;<code>cp somefile somefile.bak</code>) or&#xA0;<code>mkdir -p test-{a,b,c}/subtest-{1,2,3}</code>&#xA0;(which expands all possible combinations and creates a directory tree).</p></li><li><p>The output of a command can be treated like a file via&#xA0;<code>&lt;(some command)</code>. For example, compare local&#xA0;<code>/etc/hosts</code>&#xA0;with a remote one:</p></li></ul><div class=\"highlight highlight-sh\"><pre>      diff /etc/hosts <span class=\"pl-s\"><span class=\"pl-pds\">&lt;(</span>ssh somehost cat /etc/hosts<span class=\"pl-pds\">)</span></span></pre></div><ul><li><p>Know about &quot;here documents&quot; in Bash, as in&#xA0;<code>cat &lt;&lt;EOF ...</code>.</p></li><li><p>In Bash, redirect both standard output and standard error via:&#xA0;<code>some-command &gt;logfile 2&gt;&amp;1</code>&#xA0;or<code>some-command &amp;&gt;logfile</code>. Often, to ensure a command does not leave an open file handle to standard input, tying it to the terminal you are in, it is also good practice to add&#xA0;<code>&lt;/dev/null</code>.</p></li><li><p>Use&#xA0;<code>man ascii</code>&#xA0;for a good ASCII table, with hex and decimal values. For general encoding info,<code>man unicode</code>,&#xA0;<code>man utf-8</code>, and&#xA0;<code>man latin1</code>&#xA0;are helpful.</p></li><li><p>Use&#xA0;<code>screen</code>&#xA0;or&#xA0;<a href=\"https://tmux.github.io/\"><code>tmux</code></a>&#xA0;to multiplex the screen, especially useful on remote ssh sessions and to detach and re-attach to a session. A more minimal alternative for session persistence only is<code>dtach</code>.</p></li><li><p>In ssh, knowing how to port tunnel with&#xA0;<code>-L</code>&#xA0;or&#xA0;<code>-D</code>&#xA0;(and occasionally&#xA0;<code>-R</code>) is useful, e.g. to access web sites from a remote server.</p></li><li><p>It can be useful to make a few optimizations to your ssh configuration; for example, this<code>~/.ssh/config</code>&#xA0;contains settings to avoid dropped connections in certain network environments, uses compression (which is helpful with scp over low-bandwidth connections), and multiplex channels to the same server with a local control file:</p></li></ul><pre><code>      TCPKeepAlive=yes\n      ServerAliveInterval=15\n      ServerAliveCountMax=6\n      Compression=yes\n      ControlMaster auto\n      ControlPath /tmp/%r@%h:%p\n      ControlPersist yes\n</code></pre><ul><li><p>A few other options relevant to ssh are security sensitive and should be enabled with care, e.g. per subnet or host or in trusted networks:&#xA0;<code>StrictHostKeyChecking=no</code>,&#xA0;<code>ForwardAgent=yes</code></p></li><li><p>To get the permissions on a file in octal form, which is useful for system configuration but not available in&#xA0;<code>ls</code>&#xA0;and easy to bungle, use something like</p></li></ul><div class=\"highlight highlight-sh\"><pre>      stat -c <span class=\"pl-s\"><span class=\"pl-pds\">&apos;</span>%A %a %n<span class=\"pl-pds\">&apos;</span></span> /etc/timezone</pre></div><ul><li><p>For interactive selection of values from the output of another command, use&#xA0;<a href=\"https://github.com/mooz/percol\"><code>percol</code></a>&#xA0;or&#xA0;<a href=\"https://github.com/junegunn/fzf\"><code>fzf</code></a>.</p></li><li><p>For interaction with files based on the output of another command (like&#xA0;<code>git</code>), use&#xA0;<code>fpp</code>(<a href=\"https://github.com/facebook/PathPicker\">PathPicker</a>).</p></li><li><p>For a simple web server for all files in the current directory (and subdirs), available to anyone on your network, use:&#xA0;<code>python -m SimpleHTTPServer 7777</code>&#xA0;(for port 7777 and Python 2) and&#xA0;<code>python -m http.server 7777</code>&#xA0;(for port 7777 and Python 3).</p></li><li><p>For running a command with privileges, use&#xA0;<code>sudo</code>&#xA0;(for root) or&#xA0;<code>sudo -u</code>&#xA0;(for another user). Use<code>su</code>&#xA0;or&#xA0;<code>sudo bash</code>&#xA0;to actually run a shell as that user. Use&#xA0;<code>su -</code>&#xA0;to simulate a fresh login as root or another user.</p></li></ul>"},{"indent":4,"title":"http://cli.learncodethehardway.org/book/"},{"indent":3,"title":"How to Learn"},{"indent":4,"title":"man bash"},{"indent":2,"title":"KDE"},{"indent":3,"title":"https://en.wikipedia.org/wiki/KDE"},{"indent":3,"title":"https://www.kde.org/"},{"indent":2,"title":"Gnome"},{"indent":3,"title":"https://www.gnome.org/"},{"indent":1,"title":"Operating Systems"},{"indent":1,"content":"<ul><li><a href=\"https://en.m.wikipedia.org/wiki/Operating_systems\" title=\"Operating systems\" class=\"mw-redirect\" target=\"_blank\">Operating systems</a>&#xA0;&#x2013; set of software that manages computer hardware resources and provides common services for computer programs</li></ul>"},{"indent":2,"title":"Resources"},{"indent":3,"title":"Udacity: Advanced OS"},{"indent":4,"title":"https://www.udacity.com/course/viewer#!/c-ud189/l-3652509443/m-641659207"},{"indent":4,"title":"Summary"},{"indent":5,"title":"OS manages access to hardware resources, to protect applications from each other"},{"indent":5,"title":"OS Abstracts a lot of services"},{"indent":6,"title":"Processor/ CPU"},{"indent":7,"title":"Apps share the cpu, multiplexing"},{"indent":8,"title":"CPu Scheduling"},{"indent":7,"title":"Steps to run a specific program"},{"indent":7,"content":"Program is loaded through an OS loader, There&apos;s a memory footprint created which contains:<div><br></div><div>Heap (dynamic memory allocation), Stack (managing function calls) and Global Data (Access to global data).</div><div><br></div><div>Applications can request more resources during running.</div>"},{"indent":7,"title":"Program vs Process"},{"indent":7,"content":"A process is a running program."},{"indent":7,"title":"Process vs Thread"},{"indent":6,"title":"Memory"},{"indent":7,"title":"Address Space distinct to each process"},{"indent":6,"title":"Interprocess Communication"},{"indent":6,"title":"File System"},{"indent":6,"title":"Access to IO devices"},{"indent":6,"title":"Access to Network"},{"indent":5,"title":"OS Structure"},{"indent":6,"title":"The way the OS is structured, the stack in which different layers of services interact"},{"indent":6,"title":"types"},{"indent":7,"title":"Monolithic"},{"indent":3,"title":"https://github.com/arjun024/mkeykernel?lang=c"},{"indent":4,"title":"one type of Kernel"},{"indent":2,"title":"Flavors"},{"indent":3,"title":"DOS"},{"indent":4,"title":"MS-DOS"},{"indent":5,"title":"Both developed together but then went their separate ways"},{"indent":5,"title":"https://en.wikipedia.org/wiki/MS-DOS"},{"indent":6,"title":"Wikipedia"},{"indent":4,"title":"PC-DOS"},{"indent":3,"title":"Windows"},{"indent":3,"title":"Unix"},{"indent":4,"title":"Darwin"},{"indent":5,"title":"Apple's"},{"indent":3,"title":"Linux"},{"indent":4,"title":"My Road"},{"indent":5,"title":"https://drive.google.com/open?id=0B9tPYCpuqoIrWUZ5QU9oczRORk0"},{"indent":2,"title":"Concepts"},{"indent":3,"title":"Virtualization"},{"indent":4,"title":"Solutions"},{"indent":5,"title":"Docker"},{"indent":5,"content":"<p><b>Docker</b>&#xA0;is an&#xA0;<a href=\"https://en.wikipedia.org/wiki/Open-source\" title=\"Open-source\" class=\"mw-redirect\">open-source</a>&#xA0;project that automates the deployment of&#xA0;<a href=\"https://en.wikipedia.org/wiki/Application_software\" title=\"Application software\">applications</a>&#xA0;inside&#xA0;<a href=\"https://en.wikipedia.org/wiki/Software_container\" title=\"Software container\" class=\"mw-redirect\">software containers</a>, by providing an additional layer of abstraction and automation of&#xA0;<a href=\"https://en.wikipedia.org/wiki/Operating-system-level_virtualization\" title=\"Operating-system-level virtualization\">operating-system-level virtualization</a>&#xA0;on&#xA0;<a href=\"https://en.wikipedia.org/wiki/Linux\" title=\"Linux\">Linux</a>,&#xA0;<a href=\"https://en.wikipedia.org/wiki/Mac_OS\" title=\"Mac OS\">Mac OS</a>&#xA0;and&#xA0;<a href=\"https://en.wikipedia.org/wiki/Windows\" title=\"Windows\" class=\"mw-redirect\">Windows</a>.<sup id=\"cite_ref-SYS-CON_Media_2-0\" class=\"reference\"><a href=\"https://en.wikipedia.org/wiki/Docker_(software)#cite_note-SYS-CON_Media-2\">[2]</a></sup></p><p>According to industry analyst firm 451 Research, &quot;Docker is a tool that can package an application and its dependencies in a virtual container that can run on any Linux server. This helps enable flexibility and portability on where the application can run, whether&#xA0;<a href=\"https://en.wikipedia.org/wiki/On-premises_software\" title=\"On-premises software\">on premises</a>, public cloud, private cloud, bare metal, etc.&quot;<sup id=\"cite_ref-Linux_3-0\" class=\"reference\"><a href=\"https://en.wikipedia.org/wiki/Docker_(software)#cite_note-Linux-3\">[3]</a></sup></p>"},{"indent":6,"title":"Archeticture"},{"indent":7,"title":"https://upload.wikimedia.org/wikipedia/commons/thumb/0/09/Docker-linux-interfaces.svg/400px-Docker-linux-interfaces.svg.png"},{"indent":6,"title":"Overview"},{"indent":6,"content":"<p>Docker implements a high-level&#xA0;<a href=\"https://en.wikipedia.org/wiki/Application_programming_interface\" title=\"Application programming interface\">API</a>&#xA0;to provide lightweight containers that run processes in isolation.<sup id=\"cite_ref-infoq-201303_5-0\" class=\"reference\"><a href=\"https://en.wikipedia.org/wiki/Docker_(software)#cite_note-infoq-201303-5\">[5]</a></sup></p><p>It uses resource isolation features of the&#xA0;<a href=\"https://en.wikipedia.org/wiki/Linux_kernel\" title=\"Linux kernel\">Linux kernel</a>&#xA0;such as&#xA0;<a href=\"https://en.wikipedia.org/wiki/Cgroups\" title=\"Cgroups\">cgroups</a>&#xA0;and kernel&#xA0;<a href=\"https://en.wikipedia.org/wiki/Linux_namespaces\" title=\"Linux namespaces\" class=\"mw-redirect\">namespaces</a>&#xA0;to allow independent &quot;containers&quot; to run within a single Linux instance, avoiding the overhead of starting and maintaining&#xA0;<a href=\"https://en.wikipedia.org/wiki/Virtual_machine\" title=\"Virtual machine\">virtual machines</a>.<sup id=\"cite_ref-6\" class=\"reference\"><a href=\"https://en.wikipedia.org/wiki/Docker_(software)#cite_note-6\">[6]</a></sup></p><p>Building on top of facilities provided by the&#xA0;<a href=\"https://en.wikipedia.org/wiki/Linux_kernel\" title=\"Linux kernel\">Linux kernel</a>&#xA0;(primarily cgroups and namespaces), a Docker container, unlike a virtual machine, does not require or include a separate operating system.<sup id=\"cite_ref-Linux_3-1\" class=\"reference\"><a href=\"https://en.wikipedia.org/wiki/Docker_(software)#cite_note-Linux-3\">[3]</a></sup>&#xA0;Instead, it relies on the kernel&apos;s functionality and uses resource isolation (CPU, memory, block I/O, network, etc.) and&#xA0;<a href=\"https://en.wikipedia.org/wiki/Namespace_isolation\" title=\"Namespace isolation\" class=\"mw-redirect\">separate namespaces</a>&#xA0;to isolate the application&apos;s view of the operating system. Docker accesses the Linux kernel&apos;s virtualization features either directly using the&#xA0;<span>libcontainer</span>library, which is available since Docker&#xA0;0.9, or indirectly via&#xA0;<span><a href=\"https://en.wikipedia.org/wiki/Libvirt\" title=\"Libvirt\">libvirt</a></span>, LXC (<a href=\"https://en.wikipedia.org/wiki/Linux_Containers\" title=\"Linux Containers\" class=\"mw-redirect\">Linux Containers</a>) or&#xA0;<span><a href=\"https://en.wikipedia.org/wiki/Systemd-nspawn\" title=\"Systemd-nspawn\" class=\"mw-redirect\">systemd-nspawn</a></span>.<sup id=\"cite_ref-docker-blog-201403_4-1\" class=\"reference\"><a href=\"https://en.wikipedia.org/wiki/Docker_(software)#cite_note-docker-blog-201403-4\">[4]</a></sup><sup id=\"cite_ref-infoq-201403_7-0\" class=\"reference\"><a href=\"https://en.wikipedia.org/wiki/Docker_(software)#cite_note-infoq-201403-7\">[7]</a></sup></p><p>By using containers, resources can be isolated, services restricted, and processes provisioned to have an almost completely private view of the operating system with their own process ID space, file system structure, and network interfaces. Multiple containers share the same kernel, but each container can be constrained to only use a defined amount of resources such as CPU, memory and I/O.</p><p>Using Docker to create and manage containers may simplify the creation of highly&#xA0;<a href=\"https://en.wikipedia.org/wiki/Distributed_system\" title=\"Distributed system\" class=\"mw-redirect\">distributed systems</a>, by allowing multiple applications, worker tasks and other processes to run autonomously on a single physical machine or across multiple virtual machines. This allows the deployment of nodes to be performed as the resources become available or when more nodes are needed, allowing a&#xA0;<a href=\"https://en.wikipedia.org/wiki/Platform_as_a_service\" title=\"Platform as a service\">platform as a service</a>&#xA0;(PaaS)-style of deployment and scaling for systems like&#xA0;<a href=\"https://en.wikipedia.org/wiki/Apache_Cassandra\" title=\"Apache Cassandra\">Apache Cassandra</a>,<a href=\"https://en.wikipedia.org/wiki/MongoDB\" title=\"MongoDB\">MongoDB</a>&#xA0;or&#xA0;<a href=\"https://en.wikipedia.org/wiki/Riak\" title=\"Riak\">Riak</a>. Docker also simplifies the creation and operation of task or workload queues and other distributed systems.<sup id=\"cite_ref-CloudAve_8-0\" class=\"reference\"><a href=\"https://en.wikipedia.org/wiki/Docker_(software)#cite_note-CloudAve-8\">[8]</a></sup><sup id=\"cite_ref-Iron.io_9-0\" class=\"reference\"><a href=\"https://en.wikipedia.org/wiki/Docker_(software)#cite_note-Iron.io-9\">[9]</a></sup></p>"},{"indent":7,"title":"Benefit"},{"indent":8,"title":"Runs the Same everywhere"},{"indent":8,"title":"Lightweight and better than other virtualization services"},{"indent":9,"title":"https://www.docker.com/sites/default/files/what-is-docker-diagram.png"},{"indent":10,"title":"Traditional "},{"indent":9,"title":"https://www.docker.com/sites/default/files/what-is-vm-diagram.png"},{"indent":7,"title":"Containers"},{"indent":8,"title":"https://hub.docker.com/"},{"indent":9,"title":"Docker hub"},{"indent":6,"title":"Resources"},{"indent":7,"title":"https://www.docker.com/"},{"indent":8,"title":"Main Website"},{"indent":8,"title":"https://www.docker.com/whatisdocker"},{"indent":9,"title":"What's Docker"},{"indent":5,"title":"Vagrant"},{"indent":6,"title":"Docker vs Vagrant"},{"indent":6,"content":"<a href=\"http://stackoverflow.com/questions/16647069/should-i-use-vagrant-or-docker-io-for-creating-an-isolated-environment\">http://stackoverflow.com/questions/16647069/should-i-use-vagrant-or-docker-io-for-creating-an-isolated-environment</a><div><br></div><div><p>f your purpose is the isolation, I think docker is what you want.</p><p>Vagrant is a virtual machine manager, it allows you to script the virtual machine configuration as well as the provisioning. However, it is still a virtual machine depending on Virtual Box (or others) with a huge overhead. It requires you to have a hard drive file that can be huge, it takes a lot of ram, and performance can be not very good.</p><p>Docker on the other hand uses kernel cgroup and namespacing via lxc. It means that you are using the same kernel as the host and the same file system. You can use Dockerfile with the&#xA0;<code>docker build</code>&#xA0;command in order to handle the provisioning and configuration of your container. You have example at&#xA0;<a href=\"https://docs.docker.com/\">docs.docker.com</a>&#xA0;on how to make your Dockerfile, it is very intuitive.</p><p>The only reason you could want to use vagrant is if you need to do BSD, Windows or other non-linux development on your ubuntu box. Otherwise, go for Docker.</p></div>"},{"indent":5,"title":"VirtuallBox"},{"indent":3,"content":"Everything is handled usually by mapping. There are two main concepts:<div><br></div><div>guest OS: whatever you install on your virutal box</div><div><br></div><div>Host OS: your main OS.</div>"},{"indent":3,"title":"Kernel"},{"indent":2,"title":"Standards"},{"indent":3,"title":"POSIX"},{"indent":3,"content":"<b>POSIX</b><span>&#xA0;(</span><span class=\"nowrap\"><span class=\"IPA nopopups\"><a href=\"https://en.wikipedia.org/wiki/Help:IPA_for_English\" title=\"Help:IPA for English\">/<span><span title=\"/&#x2C8;/ primary stress follows\">&#x2C8;</span><span title=\"&apos;p&apos; in &apos;pie&apos;\">p</span><span title=\"/&#x252;/ short &apos;o&apos; in &apos;body&apos;\">&#x252;</span><span title=\"&apos;z&apos; in &apos;Zion&apos;\">z</span><span title=\"/&#x26A;/ short &apos;i&apos; in &apos;bid&apos;\">&#x26A;</span><span title=\"&apos;k&apos; in &apos;kind&apos;\">k</span><span title=\"&apos;s&apos; in &apos;sigh&apos;\">s</span></span>/</a></span></span><span>&#xA0;</span><span title=\"English pronunciation respelling\" class=\"Unicode\"><a href=\"https://en.wikipedia.org/wiki/Wikipedia:Pronunciation_respelling_key\" title=\"Wikipedia:Pronunciation respelling key\"><i><b><span class=\"smallcaps\"><span class=\"SMALLCAPS\"><span class=\"NOCAPS\">poz</span></span></span></b>-iks</i></a></span><span>), an acronym for&#xA0;</span><b>Portable Operating System Interface</b><span>,</span><sup id=\"cite_ref-1\" class=\"reference\"><a href=\"https://en.wikipedia.org/wiki/POSIX#cite_note-1\">[1]</a></sup><span>&#xA0;is a family of&#xA0;</span><a href=\"https://en.wikipedia.org/wiki/Standardization\" title=\"Standardization\">standards</a><span>&#xA0;specified by the&#xA0;</span><a href=\"https://en.wikipedia.org/wiki/IEEE_Computer_Society\" title=\"IEEE Computer Society\">IEEE Computer Society</a><span>&#xA0;for maintaining compatibility between&#xA0;</span><a href=\"https://en.wikipedia.org/wiki/Operating_system\" title=\"Operating system\">operating systems</a><span>. POSIX defines the&#xA0;</span><a href=\"https://en.wikipedia.org/wiki/Application_programming_interface\" title=\"Application programming interface\">application programming interface</a><span>&#xA0;(API), along with command line&#xA0;</span><a href=\"https://en.wikipedia.org/wiki/Unix_shell\" title=\"Unix shell\">shells</a><span>&#xA0;and utility interfaces, for software compatibility with variants of&#xA0;</span><a href=\"https://en.wikipedia.org/wiki/Unix\" title=\"Unix\">Unix</a><span>&#xA0;and other operating systems.</span><sup id=\"cite_ref-FAQ_2-0\" class=\"reference\"><a href=\"https://en.wikipedia.org/wiki/POSIX#cite_note-FAQ-2\">[2]</a></sup><sup id=\"cite_ref-IET_3-0\" class=\"reference\"><a href=\"https://en.wikipedia.org/wiki/POSIX#cite_note-IET-3\">[3]</a></sup>"},{"indent":4,"title":"https://en.wikipedia.org/wiki/POSIX"},{"indent":5,"title":"A family of standards  to provide compatibility with different operating systems"},{"indent":4,"title":"Compatible OSs"},{"indent":5,"title":"https://en.wikipedia.org/wiki/POSIX#POSIX-oriented_operating_systems"}]