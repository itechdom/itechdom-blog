[{"title":"concepts","id":8,"ideas":{"3":{"title":"Keywords","id":11,"ideas":{"1":{"title":"Mut","id":10,"attr":{"style":{}}},"2":{"title":"let","id":53,"ideas":{"1":{"title":"accepts a pattern","id":54,"ideas":{}}}}},"attr":{"collapsed":true,"style":{}}},"4":{"title":"Features","id":12,"ideas":{"1":{"title":"No Garbage collection","id":13},"2":{"title":"Reducing runtime overhead by letting the compiler do the work for us sometimes","id":14}},"attr":{"collapsed":true,"style":{}}},"5":{"title":"Macros","id":19,"ideas":{"1":{"title":"!","id":20}}},"6":{"title":"Result types","id":21,"ideas":{"1":{"title":"for encoding error information","id":22},"2":{"title":"is returned by functions as a result of an operations","id":59,"ideas":{"1":{"title":"example ","id":60,"ideas":{"1":{"title":"IO operations","id":61}}}}}},"attr":{"collapsed":true,"style":{}}},"7":{"title":"Ownership","id":23,"ideas":{"1":{"title":"Borrowing","id":24,"ideas":{"1":{"title":"Handing over a variable to a function","id":26}}},"2":{"title":"http://rust-lang.github.io/book/understanding-ownership.html","id":29}},"attr":{"collapsed":true,"style":{}}},"8":{"title":"lifetime","id":27,"ideas":{"1":{"title":"scope in other langs","id":28}},"attr":{"collapsed":true,"style":{}}},"9":{"title":"variables","id":57,"ideas":{"1":{"title":"immutable","id":58},"2":{"title":"instead of reassigning a value to a variable, we shadow","id":64,"attr":{"attachment":{"contentType":"text/html","content":"Wait a minute, I thought we already had a guess? We do, but Rust allows us to ‘shadow’ the\nprevious guess with a new one. This is often used in this exact situation, where guess starts as\na String, but we want to convert it to an u32. Shadowing lets us re-use the guess name, rather\nthan forcing us to come up with two unique names like guess_str and guess, or something else."},"style":{}}}},"attr":{"collapsed":true,"style":{}}},"10":{"title":"Control structure","id":65,"ideas":{"1":{"title":"Loop","id":66,"ideas":{"1":{"title":"infinite loop","id":68,"ideas":{"1":{"title":"break","id":69}}}}},"2":{"title":"match","id":70}},"attr":{"collapsed":true,"style":{}}},"11":{"title":"struct","id":75,"ideas":{"1":{"title":"creates a class","id":77}},"attr":{"collapsed":true,"style":{}}},"12":{"title":"impl","id":76,"ideas":{"1":{"title":"defines functions on a class","id":79}},"attr":{"collapsed":true,"style":{}}},"13":{"title":"multi-threading","id":80,"ideas":{"1":{"title":"mutexes","id":81,"attr":{"attachment":{"contentType":"text/html","content":"This Table has an vector of Mutexes. A mutex is a way to control concurrency: only one thread\ncan access the contents at once. This is exactly the property we need with our forks. We use an\nempty tuple, (), inside the mutex, since we’re not actually going to use the value, just hold onto\nit."},"style":{}}},"2":{"title":"when a thread locks a mutex, other threads have to wait till it becomes available","id":82}},"attr":{"collapsed":true,"style":{}}},"14":{"title":"calling rust from other languages","id":83,"ideas":{"1":{"title":"FFI","id":84}},"attr":{"collapsed":true,"style":{}}},"15":{"title":"Memory Management","id":86,"ideas":{"1":{"title":"Allocates to stack by default","id":87,"ideas":{"1":{"title":"Last in first out","id":88},"2":{"title":"when you call a function you allocate a new stack frame","id":89},"3":{"title":"Limited in size, but fast","id":90},"4":{"title":"Rust automatically clears up the memory once the function ends","id":96}}},"2":{"title":"Heap","id":91,"ideas":{"1":{"title":"Bigger size","id":92},"2":{"title":"Slow","id":93},"3":{"title":"Memory stays longer and has to be deallocated","id":97},"4":{"title":"Most garbage collected languages use the heap","id":98}}},"3":{"title":"use jemalloc for managing memory","id":94}},"attr":{"attachment":{"contentType":"text/html","content":"if we have 1GB of memory, then we get an array of 1 - 230<div><br></div><div><br></div><div>stack and heap both access this array.</div><div><br></div><div>heap allocates from the end</div><div><br></div><div>Stack starts from zero</div>"},"style":{}}}}},{"title":"Impressions","id":72,"ideas":{"1":{"title":"no classes, but it seems struct, impl replaces them","id":74},"2":{"title":"Rust can be really effective for expensive computation","id":85}},"attr":{"collapsed":true,"style":{}}},{"title":"Resources","id":2,"ideas":{"1":{"title":"https://www.rust-lang.org/","id":3},"2":{"title":"Docs","id":4,"ideas":{"1":{"title":"http://doc.rust-lang.org/book/README.html","id":5}},"attr":{"collapsed":true,"style":{}}},"3":{"title":"Docker hub","id":6,"ideas":{"1":{"title":"https://hub.docker.com/r/jimmycuadra/rust/","id":7}},"attr":{"collapsed":true,"style":{}}},"4":{"title":"Third party","id":15,"ideas":{"1":{"title":"Cargo","id":16,"ideas":{"1":{"title":"Package manager","id":17,"ideas":{"1":{"title":"https://crates.io/","id":18}}},"2":{"title":"TOML type","id":33,"ideas":{}},"3":{"title":"build","id":35,"ideas":{"1":{"title":"create target folder and add the bin there","id":36},"2":{"title":"--release","id":41,"ideas":{"1":{"title":"build with optimization","id":43,"ideas":{}}}}}},"4":{"title":"run","id":38,"ideas":{"1":{"title":"build and run","id":39}}},"5":{"title":"new","id":45,"ideas":{"1":{"title":"create new project","id":46},"2":{"title":"--bin","id":47,"ideas":{"1":{"title":"for not a library","id":48}}}}},"6":{"title":"update","id":62,"ideas":{"1":{"title":"ignore cargo.lock and update the dependencies","id":63}}}},"attr":{"position":[145,-55.375,1],"style":{},"collapsed":true}},"2":{"title":"Frameworks","id":49,"ideas":{"1":{"title":"Iron","id":50,"ideas":{"1":{"title":"web","id":51,"ideas":{"1":{"title":"https://github.com/iron/iron","id":52}}}}}},"attr":{"collapsed":true,"style":{}}}},"attr":{"collapsed":true,"style":{}}},"5":{"title":"https://killercup.github.io/trpl-ebook/trpl-2015-05-13-a4.pdf","id":30,"ideas":{"1":{"title":"book","id":31,"ideas":{"1":{"title":"page 119","id":71}},"attr":{"style":{}}}},"attr":{"style":{}}}},"attr":{"position":[127.5,-6,1],"style":{}}}]